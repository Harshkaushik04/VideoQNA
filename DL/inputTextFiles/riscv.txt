 Welcome back to RISC-V instruction formats. We are almost done. We have covered five different instruction formats. We just have one more to cover. That's the one that covers jumps in RISC-V. And guess what? There is only one jump instruction, which is JAL. So the format for JAL is very similar to our U format that we have seen before. It essentially needs room for a long immediate and a destination register and then of course the opcode. So the format goes like this. We have the opcode that is 7-bit, the destination register that is RD that is 5-bits and a 20-bit offset. However, shuffle the bit to look more like what we have seen in branches because we would like this to behave more like branches. What does JAL do? Just to remind ourselves, it saves the next instruction, which is the value in PC plus 4, which points to the next instruction that will be executed in the memory. So it will save PC plus 4 in the destination register. That's our return address after the function call and sets the program counter to the program counter plus offset because JAL and RISC-V support PC relative addressing for jumps as well as for branches. And the code is, can be relocated across the memory locations. Important things to remember here. The range here is actually 21-bits because we follow the same convention that we have seen in branches where we will be jumping only to even addresses in the memory. That's where we are going to find valid instructions. There is no need to jump to odd addresses because we will not find the start of either 16 or 32-bit instruction at an odd address. So we are going to jump only to even addresses. Therefore, the least significant bit of the offset has to be zero. So we are using 20 bits to specify to cover the range that is 21 bits wide. So the target is anywhere within 2 to the 19th locations, which are 2 bytes apart, 2 to the 9, plus minus 2 to the 19th locations, 2 bytes apart, which means that is plus minus 2 to the 18th 32-bit instructions is our jump range relative to the current value of the program counter. That gives us plus minus megabyte worth of code, which is quite a bit. So the only other thing to keep in mind here is that immediate encoding here is optimized in the same way as we had in the B format. We also seen the commonly used pseudo instruction J, which is a jump where we do not save the return address. So the way not save the return address is to specify the RD as x0, which would discard the value stored there. A couple of examples of using a JAL. Here is a J pseudo instruction. J label is the same as JAL without saving the return address to an address specified as a label. And then, so that label will be calculated relative to the current PC. And then, our other common use of JAL is to call a function within 2 to the 18th instructions of a PC. So this would be done as JAL RA with function name. We are going to save the return address in RA so we know where to return. And then function name would be a label that is within the reach of the JAL. And that's it. There is not much more to it. We have seen it before. There is one more JAL instruction, but we said we have had only one instruction in the J format. That's because JAL and link register is of I type. It needs room for both the destination register and the source register. So it uses the I format. So JAL is going to have its opcode, destination register, and the source register. And we'll be using only a 12-bit offset. It could have had wider offset, but decided not to develop, to add one more type of instruction format to RISC-V. So we have seen that instruction. I haven't studied it in detail. So here it is in the detail. It is JAL register specifying the destination and the source register and immediate value where immediate is a 12-bit value. So it again does two things. It writes the next address, RD, the return address of PC plus 4 in the RD, in the destination register. So we know how to return back. And then sets the program counter to a new value, which is equal to the value of the source register plus the immediate. It's an important thing to notice here. This is the way to make a jump to an absolute address. We will put a value in the source register and specify any offset with respect to that. Another important distinction. Immediates here are not like in JAL and in branches because we are using the immediate format. We can't just assume that the least significant bit is zero. It is there in the instruction. You know, it is specified in the offset. It is right there. There. So there is no multiplication by two bytes. So our range is a bit reduced. Just keep that in mind. So the way how it does it, it calculates the sum of the sign extended immediate, like we always do in the immediate in the i format. So we sign extend the immediate, add it to the source register, and then we always, by convention, set the least significant bit to zero, such that we always jump to even addresses. Here are a couple of examples of use of JAL R. So the one that we have already seen is a return or J-R, jump register with a return address. That is essentially JAL R, X0, RA, and a zero. So our source is the RA, and we don't have to our return address. We are returning to our return address. We don't need to save the destination. We don't have to save the current PC, and our offset is zero. If you want to call a function at any 32-bit absolute address, we can do that with JAL R with the help of Louis. So if we Louis upper 20 bits of our target absolute address into register X1, and then JAL R with the value of X1 and lower 12 bits that are going to be now added to that, then we are there. We have called a function that is specified by a 32-bit absolute address. Now, JAL R can also do relative addressing. The way how we do that, well, you said JAL R, isn't that a contradiction? You just said that JAL R always uses absolute addresses, but we can take it, right? We can load the current value of a PC by using our EPC. So we can load upper 20 bits in X1, and then JAL R with a lower 12 bits to our relative destination with full 32-bit offset. And that's it. That sums up all RISC-V instruction formats. When I come back, I'll just sum up.
